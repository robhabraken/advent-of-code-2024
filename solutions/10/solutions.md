# Solutions to Day 10: Hoof It

Here are my solutions to the puzzles of today. Written chronologically so you can follow both my code and line of thought.

## Part 1

Today was a bit of a step back in difficulty. At the first glance I expected pathfinding, but because they just want to know all reachable `9` paths, we don't need to look for the shortest or cheapest route, we can just traverse all paths from `0` to `9` and count the number of reachable `9`s.

I set up a delta map again, containing all deltas to each direction on the map, and created a `HashSet<Type<int, int>>` to keep track of a distinct list of x,y-coordinates we can reach on the map. I didn't bother parsing the input and started looping over the input straight away. When I find a starting point, a `0`, I start to `Walk` over that trail. After I'm done, count the number of reachable `9`s and reset my list for the next starting point.

Within `Walk`, which is a recursive function, retrieve the current height, parsing it to an integer value, and checking if it is in fact an endpoint of a trail (a `9`). If so, I'll add that location to the list of reachable locations and return, breaking out of the recursive function for this branche. For any other number I continue and look in each direction (looping over the `deltaMap`), checking if it contains a number that is exactly one higher than my current height. If so, I continue walking over the trail and call `Walk` again for that next location.

This automatically makes the code traverse each trail from each starting point, and when all paths have reached a dead end or a `9`, I can count the number of reachable `9`s and add them to the score.

## Part 2

Part two was even easier than part 1. Where we needed to find end points of trails in part 1, and thus make sure we didn't count a location twice or more times for more paths leading to the same location, we could remove that check entirely for part 2, as they now wanted to now the number of paths instead of the unique number of endpoints per starting point. In other words, I could simply remove the `HashSet<Type<int, int>>` list that kept track of all reachable `9`s and all code with it, and just increase the rating each time I landed on a `9`. Other than that, it's the same code as part 1.

*Edit: Although quite clean and elegant, my approach wasn't the fasted, as the recursive approach walks over the same path multiple times when paths overlap. My execution time was 16ms and I wanted to see if I can improve that. A colleague mentioned 'dynamic programming' and 'cache', which sounded like a good approach, so I decided to give it a shot. This time, I didn't use recursion, and didn't actually walk the trails from `0` to `9`. Instead, I looped over the entire map once for each number counting down from `8` to `0`. For each `8`, I counted the number of `9`s surrounding it, and stored that number in the current location. So if an `8` has two `9`s adjacent to it, when you are at that `8`, there are two possible paths to a `9`. These counters are stored in an additional integer map named `cache`. Next, when evaluating all numbers `7`, I look for all `8`s next to it, and add their current counter to that location: a `7` with two `8`s next to it, where one `8` has one possible path to a `9`, and the other `8` having two possible paths to a `9`, has exactly 3 possible paths to a `9` from there. And so on.. Just for each iteration, look at your neighbours and when they're one higher, add their visit counter to your own. When you reach a `0`, you can add the resulting visit counter to the answer and you're done. This approach actually is quite a bit faster as you're not calculating paths twice or more, but I think the solution is a little less elegant in terms of readability. Though that's also in part due to the fact I removed the variable declaration of  `var dY = y + deltaMap[i, 0];` and used `(y + deltaMap[i, 0])` instead for all occurences, just because that's a lot faster and I was tweaking performance (variable declaration in a loop isn't very efficient). I could've also moved the variables to being globals for performance, but that's also not good for scoping or readability. Anyway, my execution time came down from 16ms to 9s, and I had some extra fun with todays puzzle. You can check out this code in the file `Alternative.cs`, which is excluded from the build, just for reference.*